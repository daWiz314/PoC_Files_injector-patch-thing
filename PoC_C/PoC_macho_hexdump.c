/*
 * macho_hexdump.c
 * Small Mach-O-aware hex dumper that annotates section start/end markers.
 * Build: clang -o macho_hexdump macho_hexdump.c
 */

// AI GENERATED BY GPT-5 MINI
// PURELY FOR POC PURPOSES, NOT PRODUCTION QUALITY CODE.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <mach-o/loader.h>
#include <mach-o/fat.h>

#define BUFFER_SIZE (1024*4)

typedef struct {
    uint64_t offset;
    uint64_t size;
    char segname[17];
    char sectname[17];
} SectionInfo;

static int compare_sections(const void *a, const void *b) {
    const SectionInfo *A = a;
    const SectionInfo *B = b;
    if (A->offset < B->offset) return -1;
    if (A->offset > B->offset) return 1;
    return 0;
}

/* Parse Mach-O (32/64) load commands and collect sections with file offsets/sizes.
 * Returns number of sections found (>=0). On error returns -1.
 * Caller must free *out_sections when count>0.
 */
static int parse_macho_sections(FILE *f, SectionInfo **out_sections, size_t *out_count) {
    if (!f || !out_sections || !out_count) return -1;
    *out_sections = NULL;
    *out_count = 0;

    uint32_t magic;
    if (fseek(f, 0, SEEK_SET) != 0) return -1;
    if (fread(&magic, sizeof(magic), 1, f) != 1) return -1;

    if (magic == FAT_MAGIC || magic == FAT_CIGAM) {
        fprintf(stderr, "FAT binaries are not supported by this POC.\n");
        return -1;
    }

    if (magic == MH_MAGIC_64 || magic == MH_CIGAM_64) {
        struct mach_header_64 mh;
        if (fseek(f, 0, SEEK_SET) != 0) return -1;
        if (fread(&mh, sizeof(mh), 1, f) != 1) return -1;

        uint32_t sizeofcmds = mh.sizeofcmds;
        char *cmds = malloc(sizeofcmds);
        if (!cmds) return -1;
        if (fread(cmds, 1, sizeofcmds, f) != sizeofcmds) { free(cmds); return -1; }

        size_t capacity = 8;
        SectionInfo *sections = calloc(capacity, sizeof(SectionInfo));
        size_t count = 0;

        char *p = cmds;
        for (uint32_t i = 0; i < mh.ncmds; i++) {
            struct load_command *lc = (struct load_command *)p;
            if (lc->cmd == LC_SEGMENT_64) {
                struct segment_command_64 *sc = (struct segment_command_64 *)p;
                struct section_64 *sec = (struct section_64 *)(p + sizeof(struct segment_command_64));
                for (uint32_t s = 0; s < sc->nsects; s++) {
                    if (count >= capacity) {
                        capacity *= 2;
                        sections = realloc(sections, capacity * sizeof(SectionInfo));
                    }
                    sections[count].offset = sec[s].offset;
                    sections[count].size = sec[s].size;
                    strncpy(sections[count].segname, sec[s].segname, 16);
                    sections[count].segname[16] = '\0';
                    strncpy(sections[count].sectname, sec[s].sectname, 16);
                    sections[count].sectname[16] = '\0';
                    count++;
                }
            }
            p += lc->cmdsize;
        }

        free(cmds);
        if (count == 0) { free(sections); *out_sections = NULL; *out_count = 0; return 0; }
        qsort(sections, count, sizeof(SectionInfo), compare_sections);
        *out_sections = sections;
        *out_count = count;
        return (int)count;
    } else if (magic == MH_MAGIC || magic == MH_CIGAM) {
        struct mach_header mh;
        if (fseek(f, 0, SEEK_SET) != 0) return -1;
        if (fread(&mh, sizeof(mh), 1, f) != 1) return -1;

        uint32_t sizeofcmds = mh.sizeofcmds;
        char *cmds = malloc(sizeofcmds);
        if (!cmds) return -1;
        if (fread(cmds, 1, sizeofcmds, f) != sizeofcmds) { free(cmds); return -1; }

        size_t capacity = 8;
        SectionInfo *sections = calloc(capacity, sizeof(SectionInfo));
        size_t count = 0;

        char *p = cmds;
        for (uint32_t i = 0; i < mh.ncmds; i++) {
            struct load_command *lc = (struct load_command *)p;
            if (lc->cmd == LC_SEGMENT) {
                struct segment_command *sc = (struct segment_command *)p;
                struct section *sec = (struct section *)(p + sizeof(struct segment_command));
                for (uint32_t s = 0; s < sc->nsects; s++) {
                    if (count >= capacity) {
                        capacity *= 2;
                        sections = realloc(sections, capacity * sizeof(SectionInfo));
                    }
                    sections[count].offset = sec[s].offset;
                    sections[count].size = sec[s].size;
                    strncpy(sections[count].segname, sec[s].segname, 16);
                    sections[count].segname[16] = '\0';
                    strncpy(sections[count].sectname, sec[s].sectname, 16);
                    sections[count].sectname[16] = '\0';
                    count++;
                }
            }
            p += lc->cmdsize;
        }

        free(cmds);
        if (count == 0) { free(sections); *out_sections = NULL; *out_count = 0; return 0; }
        qsort(sections, count, sizeof(SectionInfo), compare_sections);
        *out_sections = sections;
        *out_count = count;
        return (int)count;
    } else {
        fprintf(stderr, "Not a Mach-O file (magic: 0x%08x)\n", magic);
        return -1;
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        return EXIT_FAILURE;
    }

    FILE *file = fopen(argv[1], "rb");
    if (!file) { perror("Error opening file"); return EXIT_FAILURE; }

    SectionInfo *sections = NULL;
    size_t nsections = 0;
    if (parse_macho_sections(file, &sections, &nsections) < 0) {
        fprintf(stderr, "Warning: could not parse Mach-O sections; hex dump will be unannotated.\n");
    } else if (nsections == 0) {
        fprintf(stderr, "No sections found in Mach-O.\n");
    } else {
        fprintf(stderr, "Found %zu sections.\n", nsections);
    }

    if (fseek(file, 0, SEEK_SET) != 0) { perror("seek"); fclose(file); free(sections); return EXIT_FAILURE; }

    unsigned char buffer[BUFFER_SIZE];
    size_t bytesRead;
    uint64_t address = 0;

    while ((bytesRead = fread(buffer, 1, BUFFER_SIZE, file)) > 0) {
        for (size_t i = 0; i < bytesRead; i++) {
            uint64_t cur = address + i;
            for (size_t s = 0; s < nsections; s++) {
                if (sections && cur == sections[s].offset) {
                    printf("\n== START %s,%s @ 0x%08llx size 0x%llx ==\n",
                           sections[s].segname, sections[s].sectname,
                           (unsigned long long)sections[s].offset,
                           (unsigned long long)sections[s].size);
                }
                if (sections && cur == sections[s].offset + sections[s].size) {
                    printf("\n== END   %s,%s @ 0x%08llx ==\n",
                           sections[s].segname, sections[s].sectname,
                           (unsigned long long)(sections[s].offset + sections[s].size));
                }
            }
            if ((i % 16) == 0) {
                printf("0x%08llx: ", (unsigned long long)cur);
            }
            printf("%02x ", buffer[i]);
            if ((i % 16) == 15) printf("\n");
        }
        address += bytesRead;
    }
    if ((address % 16) != 0) printf("\n");

    free(sections);
    fclose(file);
    return EXIT_SUCCESS;
}
